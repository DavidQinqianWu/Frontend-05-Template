# 总论

-   \* 匹配任意数量的任意字符
-   ? 匹配任意字符

# 字典树

> 适合用较大的数据
> 解析每一个字符串的收尾,依次变为各自的层级的节点, 并且合并同类项目

## 代码重点:

-   `Object.create(null)` 常用放发, 用来建造生成一个全新的什么都没有的 object, 避免受到 Object.prototype 自带的属性的影响
-   `inset()` 出入字典树节点, 如果已经在同一个层级中发现了这个字符, 那么就让当前的 node 等于这个层级的字符, 否则 就创建一个新的节点
-   `inset()` 方法中的 \$ 用来表示这个字符串的结尾处
-   `randomWord(length)` 利用了 `String.fromCharCode(Math.random() * 26 + "a".charCodeAt(0));` 这个是找到 a 的 charCode 然后利用随机数, 随机生成 0 到 26 里面的数值.
-   `fromCharCode(number)` 这个里面的 number 即使是 float 也是可以的

# KMP

> 在一个字符串中去查找另一个字符串. 模式匹配
> 传统匹配: 暴力算法 O(m\*n) 时间复杂度

1.  关注字符串的自重复行为

    -   依次删除掉我们字符串, 生成的新的字符串去 匹配最原始的老字符串 ,看看哪一个是能匹配上最多的, 看 pattern 是否有自重复的特性
    -   当我们的 pattern 串, 出现了不能匹配的时候, 我们不着急要直接回到前面, 我们应该回到 已经匹配了的位置, 就是 j 的位置

    ```javascript
    let pattern = "abcd    abce"; // 这里为了方便理解, 空格分开  j 循环
    let source = "abcd abcd abce x"; // 这里为了方便理解, 空格分开 i 循环
    // pattern 中的 e 出现不匹配的时候, 我们应该跳转到 pattern 中的 d 的位置, 继续跟 source 去比较,看看是否跟 source 继续匹配上, 因为 pattern 的自身重复性, 我们知道 只有 pattern 中的 e 匹配不上,但是 abc 在 source 中肯定是匹配上的, 所以 j 应该跳到 pattern 中的'd', 继续跟 source 匹配
    //
    ```

    -   pattern 字符串上要记录 每一个 pattern 自我遍历的时候, 已经有多少个 char 重复了: 例如 : `"abababc"` 在遍历这个 pattern 的时候, 要记录每一位 char 已经自身遍历了多少遍, 所以生成出来表示 **每一个 char** 重复次数(跳转表格) 应该是: `[0,0,0,1,2,3,4]`;

# Wildcard

> 带有通配符的匹配模式 \* ? 混合的
> 只有 \* : 任意模式匹配,可以无限长 : 最后一个 \* 尽量多匹配, 中间的 \* 尽力多匹配
> 只有 ?

## 代码分析:

-   代码总体分三段:
    1. 第一个星号,包括第一个 \* 之前的
    2. 中间的星号(字段 + \*)
    3. 最后一个星号,包括最后一个 \* 之后的
-   正则技巧: [\\s\\S] 表示任意字符, 因为 s 和 S 是互补的
